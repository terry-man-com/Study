# データベース学習メモ
- リレーショナルデータベース：データを表（２次元的）に管理するデータベースのこと。
- リレーショナルデータベースではデータが重複すると可読性が落ちるので、重複しないようにする。そのために主キーを取り入れる。

### データベースの設計
- 開発の流れ：要件定義→設計→実装→リリース　データベース設計は設計にあたる。
- データベースの設計
- 何をデータとして保存するのか？
    - システムで使用するもの（商品情報など）
    - ユーザーが登録するもの（氏名など）
    - **最初にやること**
        - データを抽出する
        - エンティティ（実態）を定義する
- どのような形式で保存するのか？
    - **主キーが必要**
        - 値を指定すれば1行のレコードを特定できる
        - テーブル内に必ず1つだけ存在
        - テーブルは重複データを持てない
    - カラムの組み合わせ毎に行を追加する
        - **第一正規形**
            - 正規形：一貫性と効率性を持った形でデータを保持するためのデータ形式
            - 正規化：一貫性と効率性を持つようにデータベースを設計する。
            - 第一正規形：1つのセルの中には1つの値しか含まない。
        - **関数従属性**
            - 主キーが決まると他のカラムの値も決まること
            - テーブル設計では全ての列が関数中属性を満たすように整理していく。
        - **第二正規形**
            - 第一正規形から部分関数従属を排除
            - 部分関数従属 = 主キーの一部に対して従属する列がある。
            - テーブル分割でデータに矛盾がなくなる。
        - **第三正規形**
            - 第二正規形から推移的関数従属を排除
            - 推移的関数従属 = テーブル内に段階的な従属関係がある
            - テーブル分割すると、他のデータと紐付かないデータも登録できる。
        - **ER図を用いて整理する**
            - テーブルとテーブルを線でつなぎ、中身の種類と関係性を見やすくしたもの
            - テーブル間の関係：１対１、１対多、多対多
            - 多対多はテーブル設計上はNG
                - 対策
                    - 中間テーブルを作る
                    - 1対多の関係となる。
            - まとめ
                - テーブルが増えていくと関係が分かりづらい
                - ER図を使って整理される。
                - テーブル間の関係は基本的には1対多
- テーブル定義
- テーブル名
    | カラム名 | データ型 | PK | NOT FULL | デフォルト |
    | ---- | ---- | ---- | ---- |---- |
    |  |  |  |  |  |

- students（例）
    | カラム名 | データ型 | PK | NOT FULL | デフォルト |
    | ---- | ---- | ---- | ---- |---- |
    | id | INT | ◯ | ◯ |  |
    | name | VARCHAR(100) |  | ◯ |  |
    | faculty_id | INT |  | ◯ |  |

- データ型（主要）
    - INT     ：整数を入れる列
    - VARCHAR ：文字列を入れる列
    - DATE    ：日付を入れる列
- テーブル定義時のポイント
    - テーブル名、カラム名、データ型、PK、NOT NULL、デフォルトを考えればOK
    - 外部キー制約、ユニーク制約、チェック制約、オートインクリメントも考慮すれば完璧
- テーブル定義後にやること
- インデックスの設定（索引を入れる）：レスポンスを上げるため
- パフォーマンスの向上（ボタンを押して、データの索引はとても時間がかかるので、そこを高速化できればサービスのパフォーマンスが向上する。）
- まとめ：手順
- 論理設計　
    - データの抽出
    - エンティティの定義
    - 正規化
    - ER図
- 物理設計
    - テーブル定義
    - インデックス設計
- まとめ：設計のポイント
- 要件を満たすテーブル/カラムを作成する
- 必要データはアプリケーションが決める
- 要件定義をしっかり行う＆理解する
- データに矛盾が生じないように正規化する。
### SQL
- データベースの種類
    - 改装型：ツリー状にデータを構成
    - ネットワーク型：網状にデータを構成
    - RDB型：表でデータを構成→DBMS
- データベース言語：データベースの管理システム（DBMS）に命令を出して、格納されているデータを抽出や解析をする際に用いる言語。**プログラミング言語のように直接コンピュータやアプリの操作はできない。**
- SQL言語の種類
    1. データ定義言語（DDL）
    - データベースやデータベース内のデータをまとめたテーブルを管理する言語。
    - 具体的には、データベースやテーブルの作成、削除ができる。データを操作するわけではなく、あくまで、箱（データベース）のために使用される。
    ```
    ・CREATE:データベースやテーブルの作成
    ・DROP:データベースやテーブルの削除
    ・ALTER:データベースやテーブルの定義変更
    ```
    1. データ操作言語（DML）
    - Date Manipulation Language,データベース内のデータを操作するための言語
    - 具体的には、データ取得、更新、登録、削除を行う。
    1. データ制御言語（DCL）
    - Date Control Language,データベースに格納されているデータを制御するための言語
    - 具体的にはユーザーグループに対してアクセス権の付与や取り消し、トランザクション処理を行う際の状態や確定などを実施したりする際に使用する。
    - トランザクションとは、複数データを同時に更新制御する必要があるときに全てのデータ更新処理が成功した時にのみデータベースに記録するデータ処理方法。Rollback:一個でもミスったら、更新前の状態に戻す。０、100思考
    ```
    ・GRANT:アクセス権付与
    ・REVOKE:権利剥奪
    ・COMMIT:トランザクションの確定
    ・ROLLBACK:トランザクションの破棄
    ```

- SQLに関する基本用語
    - テーブル：項目毎に格納されている表の単位
    - レコード：テーブルに横方向に格納されている1行分のデータ。データそのものを指す
    - カラム：縦方向に格納されているデータのこと。データを保管する場所。データベースの最上段にデータが何に属するのかを示すラベルがあり、それによって、データの意味がわかる。この最上段でデータが属するラベルを示す値を（属性）をいう。
    - フィールド：データベースに格納されているデータの最小単位で、フィールドの集まりがレコードやテーブルになる。Excelで言うところのセル。
    - 主キー：レコード（行）全体のうち、一つのレコードデータを識別するためにデータベースが保証したカラム。主キーが分かれば、行内の他のデータもきまる。関数従属性。社員番号が決まれば、社員名がわかるのようなもの。重複することは許されない。なぜならば、同じ社員番号（主キー）に違う値があった場合、どちらを参照してよいかDBMSが判断できないためである。
- SQLが使える主要なデータベース
    - MySQL:Oracleが開発。もっとも利用者が多いRDB型のDBMS。オープンソースソフトウェアなので誰でも自由に利用できることが利点（非商用であれば無料で利用可能、初心者でも導入しやすい）。データベースを作成・更新・削除するストレージエンジンがさまざまなアプリケーションに対応しているため、拡張性が高い。
    - Maria DB:MySQLからの派生版。以下の機能が追加されている。
    ```
    ・並列処理の性能向上
    ・サーバーの柔軟な切り替え
    ・権限管理の効率化
    ```
    また、MySQLから簡単に移行できる点も魅力の一つである。
    - PostgreSQL:オープンソースのRDB型DBMS。Linuxなど主要なUNIX系OSやWindowsに対応し、機能の豊富さや拡張性の高さからデータベースサーバーとしてはOracle,MySQL,Microsoft SQL Serverに次いで４位
    - Oracle Database:災害対策やデータを巻き戻す機能など、障害に対する機能が充実しており、その堅牢性が特徴である。
    - SQ Lite:設定の必要がない自己完結型データベースであり、外部プラットフォームに依存することなく利用が可能である。
- CRUD
    - 登録・変更・削除・参照機能
    - Create・Read・Update・Deleteの略
### Cookie, LocalStorage
- Cookieについて
    - HTTP通信はステートレスな通信である。情報を保持しないで1回のリクエストとレスポンスのやり取りで情報を破棄する。がAmazonのようなECだとログインした後にその情報を引き継いで、買い物カゴに追加したりできないと決済できない。これはHTTP通信では実現できないため、**ブラウザ側で記録する必要がある。**そのための技術がCookeiやWeb Storageである。要するにユーザーの情報（会員情報など）をブラウザで保持して,カゴに追加し、決済までするのはそれによって実現されてる。ログイン情報など個人と識別する情報をもとに処理をするECサイトなどで用いられる。名札代わりでその名札を持ったクライアントがサーバーで情報をもらうようなイメージ。
    - document.cookie:Cookieの読み書きや削除を行うことができる。
        - すべてのCookieを読み込む
        ```
        const cookie = document.cookie;
        console.log(cookie); // key=value; key=value; key=value; key=value; key=value; key=value;
        ```
        - 特定のCookieを探す場合（Cookieの分割を行う） ex.Cookie毎に分割して値を取得する
        ```
        const cookies = document.cookie;
        // splitメソッド：文字列型のメソッド、;で要素を区切り、配列として変数に格納する
        const array = cookies.split(';');　
        // 配列arrayの要素を一つずつ取り出し、valueに入れて、以下の処理を行う。
        array.forEach(function(value) {
        // valueのkey=valueをcontent[0]key、content[1]valueの状態にする。
        const content = value.split('=');
        console.log(content[1]); // valueを取得
        })
        /*
        value
        value
        value
        .....
        */
        ```
        - forEachは関数を引数に取る。
        - Cookieの書き込み
            - `document.cookie`に値を入れるだけ。
            ```
            document.cookie = "user=Tarou";
                // key=value、当たり前だけど、書き込みたいkeyを指定し、値を入れる感じ
            console.log(document.cookie); // user=Tarou
            ```
            - オプションとしてCookieの有効期限を設定することが可能である。max-ageまたはexpires、セミコロン区切り
            ```
            document.cookie = "user=Tarou; max-age=3600"; // 1時間後に消える
            ```
        - Cookieの削除
            - 有効期限をmax-age,expiresで0にするか、過去の日付を指定する。
            ```
            // 有効期限を過去に設定
            document.cookie = "user=Tarou; expires=Mon, 1 Nov 2021 20:00:00 GMT";
            // 有効期限を0に設定
            document.cookie = "user=Tarou; max-age=0";
            ```
        - js-cookie:より気軽に操作が可能。npmパッケージのjs-cookieを導入することによって利用可能。npmやypmコマンドで利用ができるようになる。
        - Cookieの読み込み
            - Cookie.get()を使用する。引数にCookieのキーを渡すと値を取得できる。引数を空欄にすると全てのCookieを取得できる。
            ```
            Cookies.get('key'); // 'value'
            Cookies.get(); // {key: 'value'}
            ```
        - Cookieの書き込み
            - Cookie.set()を使用。引数にCookieのキーと値を格納する。
            ```
            Cookies.set('key', 'value');
            Cookies.set('key', 'value', {expires: 14}); // 14日後に消える。
            Cookies.set('locale', 'ja-JP'); // ユーザーの使用言語を日本語に設定する。
            ```
        - Cookieの削除
            - Cookie.remove()を使用する。引数にCookieのキーを渡すと削除可能
            ```
            Cookies.remove('value');
            ```
        - https(SSL/TLS)通信時のみにCookieを送信
            ```
            Cookies.set('key', 'value', { secure: true });
            ```
- LocalStorageについて
    - 概要：javascriptを用いてクライアント側にデータを保存する仕組み
    - LocalStorageの特徴とCookieとの違い
        - LocalStorageの特徴
            1. 保存容量がブラウザによって異なる（5MB〜10MB）
            1. サーバへ値を送信しない
            1. 無制限
        フロントエンドのみで利用されるので、データ自体はブラウザに保存される。Cookieと異なり、サーバーへデータ送信されないので、通信に影響がない。Amazon「最近見た商品」などに使われている。
        - Cookieとの性能の比較
        Cookie
            1. 保存容量が最大4KB
            1.リクエストの度にサーバーへ値を送信する
            1.有効期限を任意に決められる。
        フロントでもバックエンドでも利用できるが、サーバとの通信の度にデータが送信されるので、通信リソースを少なからず使用してしまう。
        - Localstorageの注意点
        半永久的にデータを保持するため、無駄なデータをクライアント側に保持させることになる可能性がある。また、誤ったデータがLocalstorageに保存された場合、クライアント側で保持されるので、修正が難しくなる。そのため、中長期的に運用する場合は注意が必要である。
    - 使い方
        - LocalStorageへデータを保存する
        ```
        var num = 1;
        // データの保存
        localStorage.setItem('access_count', num);
        window.localStorage.setItem('access_count', num);
        localStorage.access_count = num
        ```
        - LocalStorageからデータを取得
        ```
        // データの取得
        num = localStorage.getItem('access_count');
        num = window.localStorage.getItem('access_count');
        num = localStorage.access_count      
        ```
        - LocalStorageからデータを削除
        ```
        // データの削除
        localStorage.removeItem('access_count');
        window.localStorage.removeItem('access_count');
        ```
        - LocalStorageの初期化
        ```
        localStorage.clear();
        ```
